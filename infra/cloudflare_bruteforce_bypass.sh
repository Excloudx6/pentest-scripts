#!/bin/bash

red="\e[31m"
green="\e[32m"
yellow="\e[33m"
reset="\e[0m"

banner(){
    echo ""
    echo -e "\t\t                             ████    "
    echo -e "\t\t               █  █         ██       "
    echo -e "\t\t               █  ██       ██        "
    echo -e "\t\t█       █      █ ███ ██   ███    █   "
    echo -e "\t\t██      ██     █ █████   ███    ██   "
    echo -e "\t\t ███    ██   ███ ████  ██████  ██    "
    echo -e "\t\t  ███   █   ███ ████████████████     "
    echo -e "\t\t    ██  ██  ██████   ███    ████    █"
    echo -e "\t\t █   █   ████████     ██     ███   ██"
    echo -e "\t\t ██  ███████████             ███████ "
    echo -e "\t\t ██   █████                   █████  "
    echo -e "\t\t  █████████                   ████   "
    echo -e "\t\t   ████               ██      ███    "
    echo -e "\t\t █████                ██      ██     "
    echo -e "\t\t██████          ██    ██      ███████"
    echo -e "\t\t █████    ██    ██    ██       █████ "
    echo -e "\t\t ████     ██    ██     ██      ██    "
    echo -e "\t\t ████     ██    ██     ██      ██    "
    echo -e "\t\t █████    ██    ██     ██      ███   "
    echo -e "\t\t  ████    ██    ██     ██      █████ "
    echo -e "\t\t █████    ██    ██     ██    ███  ███"
    echo -e "\t\t███ ███   ██    ██     ████ ████     "
    echo -e "\t\t██  ████  ███   ████ ████████████    "
    echo -e "\t\t█     ██ █████ ████████      ██ ██   "
    echo -e "\t\t       █████████████  ███    ██      "
    echo -e "\t\t      ███ ██ █████████    ████       "
    echo -e "\t\t      ██ ██  ███   █████████         "
    echo -e "\t\t         ██   █    ██     ██         "
    echo -e "\t\t         █  ████   ██      ██        "
    echo -e "\t\t            ████   ██       █        "
    echo -e "\t\t              ██  ██                 "
    echo -e "\t\t              ██  █                  "
    echo -e "\t\t             ███                     "
    echo -e "\t\t             █                       "
    echo ""
}

banner

if [ ${EUID} -ne 0 ]; then
    echo -e "Please, execute this script with ${red}root${reset} or ${red}sudo${reset}..."
    echo "Because the need to edit /etc/hosts file!"
    exit 1
fi

if [ -z $(command -v html2text) ]; then 
    echo -e "Please, install html2text with:\n"
    echo "    pip install html2text"
    exit 1
fi

options+=(-d --domain -e --exclude-ips -n --network -o --output-dir -u --url-path)

check_argument(){
    if [[ "${options[@]}" =~ "$1" ]]; then
        echo -e "The argument of ${yellow}\"$1\"${reset} it can not be ${red}\"$2\"${reset}, please, ${yellow}specify a valid one${reset}.\n"
        exit 1
    fi
}

usage(){
    echo -e "\nUsage:"
    echo -e "\t-d|--domain      - specify the domain you want to brute ${yellow}[${reset}${red}needed${reset}${yellow}]${reset}."
    echo -e "\t-e|--exclude-ips - specify a list of IPs you want to exclude from test."
    echo -e "\t-n|--network     - specify the network to obtain the list of IPs to test ${yellow}[${reset}${red}needed${reset}${yellow}]${reset}."
    echo -e "\t-o|--output-dir  - specify the local to output."
    echo -e "\t-u|--url-path    - if the test is a specific URL you need to put the path here like \"the/path/is/here\""
    echo -e "\t\t\t   with the quotation marks because the URL maybe contain \"&\" no broke the script execution."
    exit 1
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--domain)
            check_argument $2
            if [[ $(dig "$2" +short +time=5 +tries=3 @1.1.1.1 2> /dev/null) ]]; then
                subdomain="$2"
                cloudflarebypass_ips_file="$(echo ${subdomain} | sed -e 's/\./_/')_ips.txt"
                cloudflarebypass_result_file="$(echo ${subdomain} | sed -e 's/\./_/')_result.txt"
                [[ ! -s "${cloudflarebypass_ips_file}" ]] && > "${cloudflarebypass_ips_file}"
                [[ ! -s "${cloudflarebypass_result_file}" ]] && > "${cloudflarebypass_result_file}"
                shift 2
            else
                echo "Please provide a valid domain."
                usage
            fi
            ;;
        -e|--exclude-ips)
            check_argument $2
            set -f 
            IFS=","
            cloudflarebypass_ip_deleted+=($2)
            unset IFS
            shift 2
            ;;
        -n|--network)
            check_argument $2
            IPv4_regex='^((25[0-5]|2[0-4][0-9]|[01][0-9][0-9]|[0-9]{1,2})[.]){3}(25[0-5]|2[0-4][0-9]|[01][0-9][0-9]|[0-9]{1,2})$'
            network="$(echo $2 | awk -F'/' '{print $1}')"
            cidr="$(echo $2 | awk -F'/' '{print $2}')"
            cidr_check_number='^[0-9]$'
            if [ -z "${network}" ] || [ -z "${cidr}" ]; then
                echo "You need to inform the network designation."
                usage
            fi
            if [[ ! ${network} =~ ${IPv4_regex} ]]; then
                echo "Please, the argument must be a valid IP address."
                usage
            fi
            if [[ ${cidr} =~ ${cidr_check_number} ]] || [[ ${cidr} -gt 32 || ${cidr} -le 0 ]]; then
                echo "Please, the cidr must be a number and between 1 and 32."
                usage
            fi
            shift 2
            ;;
        -o|--output-dir)
            check_argument $2
            unset cloudflarebypass_output_dir
            unset cloudflarebypass_ips_file
            unset cloudflarebypass_result_file
            [ ! -d "$2" ] && mkdir -p "$2" 2> /dev/null
            if [[ $(cd $2 > /dev/null 2>&1 ; echo "$?") -eq 0 ]] \
                && [[ $(touch $2/permission_to_write.txt > /dev/null 2>&1; echo "$?") -eq 0 ]]; then
                cloudflarebypass_output_dir="$(echo $2 | sed -e 's/\/$//')"
                rm -rf "${output_dir}/permission_to_write.txt"
                cloudflarebypass_ips_file="${cloudflarebypass_output_dir}/$(echo ${subdomain} | sed -e 's/\./_/')_ips.txt"
                cloudflarebypass_result_file="${cloudflarebypass_output_dir}/$(echo ${subdomain} | sed -e 's/\./_/')_ips.txt"
                [[ ! -s "${cloudflarebypass_ips_file}" ]] && > "${cloudflarebypass_ips_file}"
                [[ ! -s "${cloudflarebypass_result_file}" ]] && > "${cloudflarebypass_result_file}"
                shift 2
            else
                echo -e "Please, you need to specify a ${yellow}valid directory you own or have access permission${reset}!\n"
                usage
            fi
            ;;
        -u|--url-path)
            check_argument $2
            url_path=$2
            shift 2
            ;;
        -?*)
            usage
            ;;
        *)
            break
    esac
done

if [[ -z "${subdomain}" ]] || [[ -z "${network}" || -z "${cidr}" ]]; then
    echo "You need to pass two needed parameters -d|--domain and -n|--network to have this script executed!"
    usage
fi

echo -n "Preparing the environment... "
if [[ $(grep -q -E "${network}.*${subdomain}" /etc/hosts ; echo $?) -ne 0 ]]; then
    echo "${network} ${subdomain}" >> /etc/hosts
fi
domain_etchosts_line="$(grep -En "^.*${subdomain})$" /etc/hosts | awk -F':' '{print $1}')"
http_code_check=200
echo "Done!"

echo -n "Getting IP list... "
network_result="$(curl -s "http://jodies.de/ipcalc?host=${network}&mask1=${cidr}" | \
    html2text | sed "s/^[[:blank:]]*//g" | \
    grep -E "^Address|^Netmask|^Wildcard|^=>|^Network|^Broadcast|^HostMin|^HostMax|^Hosts/Net"
)"

if [ ${cidr} -eq 32 ]; then
    host_min=$(echo "${network_result}" | grep -E "^HostMin:" | awk '{print $2}')
    host_max=$(echo "${network_result}" | grep -E "^HostMax:" | awk '{print $2}')
    if [ "${host_min}" == "${host_max}" ]; then
        echo "${host_max}" >> "${cloudflarebypass_ips_file}"
    fi
elif [ ${cidr} -eq 24 ]; then
    network_octets=$(echo "${network_result}" | grep -E "^Network:" | awk '{print $2}' | cut --output-delimiter='.' -d'.' -f 1-3)
    host_count=$(echo "${network_result}" | grep -E "^HostMin:" | awk -F'.' '{print $4}' | cut -d' ' -f1)
    host_final=$(echo "${network_result}" | grep -E "^HostMax:" | awk '{print $2}')
    while [[ "${ip}" != "${host_final}" ]] ; do
        ip="${network_octets}.${host_count}"
        (( host_count += 1 ))
        echo "${ip}" >> "${cloudflarebypass_ips_file}"
    done
else
    network_initial=$(echo "${network_result}" | grep -E "^HostMin:" | awk -F'.' '{print $3}')
    network_final=$(echo "${network_result}" | grep -E "^HostMax:" | awk -F'.' '{print $3}')
    network_octets=$(echo "${network_result}" | grep -E "^Network:" | awk '{print $2}' | cut --output-delimiter='.' -d'.' -f 1-2)
    network_count=${network_initial}
    host_count=$(echo "${network_result}" | grep -E "^HostMin:" | awk -F'.' '{print $4}' | cut -d' ' -f1)
    host_final=$(echo "${network_result}" | grep -E "^HostMax:" | awk '{print $2}')
    while [[ "${ip}" != "${host_final}" ]] ; do
        ip="${network_octets}.${network_count}.${host_count}"
        (( host_count += 1 ))
        if [ ${host_count} -gt 255 ]; then
            host_count=0
            [[ ${network_count} -lt ${network_final} ]] && (( network_count += 1 ))
        fi
        echo "${ip}" >> "${cloudflarebypass_ips_file}"
    done
fi

if [ ${#cloudflarebypass_ip_deleted[@]} -gt 0 ]; then
    for ip in ${cloudflarebypass_ip_deleted[@]}; do
        sed -i "/${ip}/d" "${cloudflarebypass_ips_file}"
    done
fi
echo "Done!"

echo -n "Searching the direct IP for ${subdomain}/${url_path} with $(wc -l ${cloudflarebypass_ips_file} | awk '{print $1}') IPs... "
for ip in $(cat "${cloudflarebypass_ips_file}"); do
    sed -i "${domain_etchosts_line}s/.*${subdomain}$/${ip} ${subdomain}/" /etc/hosts
    http_code=$(curl -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36' -o /dev/null -s -w "%{http_code}\n" --connect-timeout 5 "https://${subdomain}/${url_path}")
    if [[ ${http_code} -eq ${http_code_check} ]]; then
        echo "Done!"
        echo -e "${domain}\t${ip}" | tee -a "${cloudflarebypass_result_file}"
        exit 0
    else
        sed -i "/${ip}/d" "${cloudflarebypass_ips_file}"
    fi
done
echo "Fail!"
