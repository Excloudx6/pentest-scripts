#!/bin/bash

# This function just check if the selected port is available before use it. 
check_if_port_available(){
    # 0(Zero) means that the port is not available and 1 means that this port is available
	PORT_FREE=0 
	REQUESTED_PORT="$1"
	while [ ${PORT_FREE} -lt 1 ]; do 
        # Check if this port is available
        if [[ $(netstat -ln | grep -q ":${REQUESTED_PORT}" 2> /dev/null) ]]; then
			REQUESTED_PORT="$((REQUESTED_PORT + 1))"
            # Call this function again to check if the new port is available
			check_if_port_available "${REQUESTED_PORT}" 
		else
			NEXT_PORT_AVAILABLE="${REQUESTED_PORT}"
            # The port is available. Exit the loop
			PORT_FREE=1 
		fi
	done
}

# This function is executed after the execution of the function: random_country
# This function executes the function boot_tor_instances
boot_tor_per_country(){
    if [ -n "${MY_COUNTRY_LIST}" ]; then
	    for country_code in ${MY_COUNTRY_LIST}; do
		    if [ -n "${country_code}" ]; then
    			CURRENT_COUNTRY=${country_code}
	    		echo "Starting (${TOR_INSTANCES}) TOR instances enforcing the (${COUNTRY_LIST_CONTROLS}) in the COUNTRY: ${CURRENT_COUNTRY}"
                # Call the declared function
		    	boot_tor_instances 
    		fi
	    done
    else
	    echo "Your MY_COUNTRY_LIST is empty!"
        echo "You should define the list of country codes will be used."
        echo "Sample: {US},{IT},{FR},{CA},{CH},{SE},{RU},{CH},{JP},{BR}"
	    exit 1
    fi
}

# This function select the initial random countries.
random_country(){ 
    for c in $(seq "${COUNTRIES}"); do
        # Sub Function to generate the LIST of COUNTRIES
	    remove_duplicate_country(){
		    if [ "${MY_COUNTRY_LIST}" = "FIRST_EXECUTION" ]; then
			    MY_COUNTRY_LIST="${COUNTRY_CANDIDATE}"
    		else
                # If the country candidate was not found in the current country list
	    		if ! grep -q -i "${COUNTRY_CANDIDATE}" "${MY_COUNTRY_LIST}" 2> /dev/null; then
				    MY_COUNTRY_LIST=$(printf '%s\n%s\n' "${MY_COUNTRY_LIST}" "${COUNTRY_CANDIDATE}")
    			else
                    # If the country already exist in the list select another country
	    			sort_country
		    	fi
		    fi
    	}
        # Sub Function to select a random contry
	    sort_country(){ 
		    COUNTRY_CANDIDATE=$(echo "${ACCEPTED_COUNTRIES}" | sed "s|,|\n|g" | sort -R | head -n 1)
            # Call the declared function
    		remove_duplicate_country
	    }
        # Call the declared function
    	sort_country
    done
    # Now we have the list of random countries defined. Let's boot the tor using this random list.
    # Call the declared function
    boot_tor_per_country
}

create_new_instance_files(){
# Writing the TOR CONFIG FILE
echo "SocksPort ${LISTEN_ADDR}:${TOR_CURRENT_SOCKS_PORT}
#This LOG options do not compromise your security.
Log notice file ${LOGDIR}${TOR_CURRENT_INSTANCE}/${LOGNAME}${TOR_CURRENT_INSTANCE}.log
#This options INFO and DEBUG can put in the log sensitive data.
#avoid to use it if possible, or just use for debug.
#Log info file ${LOGDIR}${TOR_CURRENT_INSTANCE}/${LOGNAME}${TOR_CURRENT_INSTANCE}.log
#Log debug file ${LOGDIR}${TOR_CURRENT_INSTANCE}/${LOGNAME}${TOR_CURRENT_INSTANCE}.log
RunAsDaemon 1
CookieAuthentication 0
ControlPort ${LISTEN_ADDR}:${TOR_CURRENT_CONTROL_PORT}
HashedControlPassword ${TORPASS}
PidFile ${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}/tor${TOR_CURRENT_INSTANCE}.pid
DataDirectory ${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}
HiddenServiceDir ${HIDDEN_SERVICE_PATH}${TOR_CURRENT_INSTANCE}
HiddenServicePort ${HIDDEN_SERVICE_CURRENT_PORT}
HiddenServiceMaxStreams 0
HiddenServiceMaxStreamsCloseCircuit 0
HiddenServiceDirGroupReadable 0
HiddenServiceNumIntroductionPoints 3
DirCache 1
DataDirectoryGroupReadable 0
CacheDirectory ${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}
CacheDirectoryGroupReadable 0
DisableDebuggerAttachment 1
FetchDirInfoEarly 0
FetchDirInfoExtraEarly 0
FetchHidServDescriptors 1
FetchServerDescriptors 1
FetchUselessDescriptors 0
KeepalivePeriod ${MINIMUM_TIMEOUT}
ProtocolWarnings 1
TruncateLogFile 1
SafeLogging 1
KeepBindCapabilities auto
HardwareAccel 0
AvoidDiskWrites 0
CircuitPriorityHalflife 1
ExtendByEd25519ID auto
NoExec 1
EnforceDistinctSubnets 1
TransPort 0
NATDPort 0
ConstrainedSockSize 8192
UseGuardFraction auto
UseMicrodescriptors auto
ClientUseIPv4 1
ClientUseIPv6 0
ClientPreferIPv6ORPort auto
PathsNeededToBuildCircuits -1
#ClientBootstrapConsensusAuthorityDownloadSchedule 6, 11, 3600, 10800, 25200, 54000, 111600, 262800
ClientBootstrapConsensusAuthorityDownloadInitialDelay 6, 11, 3600, 10800, 25200, 54000, 111600, 262800
ClientBootstrapConsensusFallbackDownloadSchedule 0, 1, 4, 11, 3600, 10800, 25200, 54000, 111600, 262800
ClientBootstrapConsensusAuthorityOnlyDownloadSchedule 0, 3, 7, 3600, 10800, 25200, 54000, 111600, 262800
ClientBootstrapConsensusMaxInProgressTries 3
RejectPlaintextPorts ${RejectPlaintextPorts}
WarnPlaintextPorts ${WarnPlaintextPorts}
CircuitBuildTimeout ${CircuitBuildTimeout}
LearnCircuitBuildTimeout ${LearnCircuitBuildTimeout}
CircuitsAvailableTimeout ${CircuitsAvailableTimeout}
CircuitStreamTimeout ${CircuitStreamTimeout}
ClientOnly ${ClientOnly}
ConnectionPadding ${ConnectionPadding}
ReducedConnectionPadding ${ReducedConnectionPadding}
GeoIPExcludeUnknown ${GeoIPExcludeUnknown}
StrictNodes ${StrictNodes}
FascistFirewall ${FascistFirewall}
FirewallPorts ${FirewallPorts}
LongLivedPorts ${LongLivedPorts}
NewCircuitPeriod ${NewCircuitPeriod}
MaxCircuitDirtiness $(shuf -i10-${MaxCircuitDirtiness} -n1)
MaxClientCircuitsPending ${MaxClientCircuitsPending}
SocksTimeout ${SocksTimeout}
TrackHostExitsExpire ${TrackHostExitsExpire}
UseEntryGuards ${UseEntryGuards}
NumEntryGuards ${NumEntryGuards}
NumDirectoryGuards 0
GuardLifetime 0
AutomapHostsOnResolve 0
AutomapHostsSuffixes ${AutomapHostsSuffixes}
SafeSocks ${SafeSocks}
TestSocks ${TestSocks}
AllowNonRFC953Hostnames ${AllowNonRFC953Hostnames}
ClientRejectInternalAddresses ${ClientRejectInternalAddresses}
DownloadExtraInfo ${DownloadExtraInfo}
OptimisticData ${OptimisticData}
" >> "${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}/tor_${TOR_CURRENT_INSTANCE}.cfg"

# HAPROXY Appending Config
echo "    server TOR_INSTANCE_${PRIVOXY_CURRENT_INSTANCE} ${PRIVOXY_LISTEN}:${PRIVOXY_CURRENT_PORT} check inter ${HEALTH_CHECK_INTERVAL} fall ${HEALTH_CHECK_MAX_FAIL} rise ${HEALTH_CHECK_MININUM_SUCESS} observe layer7 minconn 1 maxconn ${MAX_CONCURRENT_REQUEST}" >> "${HAPROXY_MASTER_PROXY_TMP_CFG}"

# Expect 
echo "#!/usr/bin/expect -f
spawn telnet 127.0.0.1 ${TOR_CURRENT_CONTROL_PORT}
expect \"Escape character is '^]'.\"
send \"AUTHENTICATE \\\"${RAND_PASS}\\\"\\r\"
expect \"250 OK\"
send \"signal NEWNYM\r\"
expect \"250 OK\"
send \"quit\\r\" " > "${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}/tor_expect.exp"
		
echo "expect ${TOR_TEMP_FILES}/tor${TOR_CURRENT_INSTANCE}/tor_expect.exp > /dev/null 2>&1" >> "${TOR_TEMP_FILES}/force_new_circuit_temp.txt"
}
